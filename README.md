# Golang Notes

- executables must have `main.go` file which must also have `main` func
- otherwise it will be considered helper package and won't generate executable
- define new variables with `:=` as shorthand
- redefine existing variables just with `=`
- We can initialize variables outside of functions, but we cannot assign them values outside of functions
- Go has two data structures to handle lists of data, Array and Slice
- Slices and Arrays must be defined with a data type
- Every element in both an Array and a Slicemust be of the same type
- Array is a fixed length list of things
- Slice is an array that can grow or shrink
- `append()` function can allow you to add new element to end of slice
  - HOWEVER-- rather than modifying the existing slice, it creates a new one slice gets assigned to new variable
- To run and compile multiple packages, run something like `go run main.go deck.go`
- Receiver functions setup methods on variables that we create
- Byte slice is like a string of characters
  - a string that translates ascii characters into a string
  - for example: Hi There! translatest to [72 105 32 116 104 101 114 101 33]
  - translations available at https://www.asciitable.com/
- Type conversion can take one type and make it another type
  - ie `[]byte("Hi there!")` would take the provided string and convert it to a byte slice
- Test functions are written with PascalCase instead of camelCase
  - Always start test func names with `Test`
  - Include all functions being tested in the test name
    - ie-- `TestSaveToDeckAndNewDeckFromFile` would be testing the `saveToDeck` and `newDeckFromFile` functions
- Struct is short for data structure-- collection of properties that are related together
  - example of Card struct field definition would be a struct field has a suit which is a string, and a value which is a string
    - similar to how JS object/Ruby hash works
  - Go is a pass by value language-- "Pass by value" means that when we pass some value into a function, Go will take the struct, copy it, and place it inside the computer's memory
    - So when we call `updateName` function, it isn't updating the new value with `p.firstName = ...`, it's just copying the struct as a new value in a different bit of the memory
    - `&variable` operator-- give me memory address of value this is pointing at
      - can turn value into address with `&value`
    - `*pointer` operator-- give me the value this memory address is pointing at
      - Can turn address into a value with `*value`
      - if we define a pointer receiver, Go will let us call the function with a pointer type or the non-pointer equivalent
    - The above is more for Structs, Slices work differently
  - Slice v Array
    - Slice can grow/shrink, used 99% of the time for lists of elements
      - Slice is made up of data structure and array, so when we access a slice variable we're getting the ds not the array
        - Pointers are used for this type of issue
    - Array is primitive data structure, can't be resized, rarely used directly
      - Arrays can be updated without pointers because it's pointing at the singular memory address
- Value Types vs Reference Types-- value types use pointers to change things in a function, reference types don't worry about pointers
  - Value types: int, float, string, bool, structs
  - Ref Types: slices, maps, channels, pointers, functions
- Maps, like Structs, are like Ruby hashes and JS obejcts
  - Keys and values are statically typed-- so all keys must be same type and all values have to be set of type
    - So something like `Record<string, number>` in TS, where all keys would be strings and all values would be numbers
- Maps V Structs
  - Maps
    - Reference Type!
    - all keys must be the same type, all values must be the same type
    - keys are index (we can iterate over them)
    - Use to represent collection of related properties
    - Don't need to know all keys at compile time
  - Structs
    - Value Type!
    - values can be of different types
    - Keys don't support index (not interable)
    - Use to represent a thing with lots of different properties
    - You need to know all fields at compile time
- Interfaces
  - Interfaces allow us to declare types that check other types for a property
  - If it has that propety then it is accepted into the interface
  - FOR EXAMPLE CHECK `/interfaces/main.go`
  - OR...
    - HYPOTHETICALLY-- you have types `englishBot` and `spanishBot` and they both have receiver functions called `getGreeting` which returns a string
    - you could then declare interface `bot` with `type bot interface { getGreeting() string }` --> any type that has a function of `getGreeting` returning a string, it is considered a member of that interface
      - So in this hypothetical, `englishBot` and `spanishBot` are both members of the `bot` interface
  - Concrete types are built in types and types we build by extending those-- such as map, struct, int, string, or englishBot
  - Interfaces are not generic types (generic types are things in other languages like C# and Java)
  - Interfaces are 'implicit'-- we don't manually say that our custom type satisfies some interface
  - Interfaces are a contract to help us manage types-- Garbage In -> Garbage Out
    - If our custom type's implementation of a fcuntion is broken then interfaces won't help us
  - Interfaces are tough-- step #1 is understanding how to read them
    - Understand how to read interfaces in the standard lib
    - Writing your own interfaces is tough and requires experience$$
- Concurrency-- allows us to have multiple threads executing code-- if one thread blocks, another one is picked up and worked on
- Parallelism-- multiple threads executed at the same time, requiring multiple CPUs
- Channels and Go Routines
  - Both are structs in Go that are used to handle concurrency
  - Go Routines
    - when we compile and execute a Go program, we automatically create one Go Routine
    - Go Routine something that exists in the running program/process
    - Main is the routine created when launch our program, child routines (declared with `go` keyword) are treated as secondary
    - GR takes every line of code and executes them one by one
    - Can run a function on a new routine by executing with with `go`-- so instead of `checkLink(link)` it would be `go checkLink(link)`
      - run this function inside of a brand new routine
      - acts as a second engine so it can run each fetch asynchronously
    - each time a routine is launched, we're launching a new engine
    - Go Scheduler-- works with one CPU on our local machine-- even if running dual core, will default to running 1 CPU core
      - scheuler runs ONE routine until it finishes or makes a blocking call (like HTTP request)
      - monitors code that is running within each individual routine
      - once scheduler detects routine has finished or is making a blocking call, then it manages the routines
        - ie-- if one is done then it'll start another
  - Channels
    - used to communicate between different running Go Routines
    - can use channels to indicate when child routines have finished so Main routine doesn't prematurely terminate
    - Channels are typed-- data shared between routines must be same types-- so you can have a channel of type string, type int, etc.
    - if you need to receive a channel in your main function when no channel exists, the program will just hang
